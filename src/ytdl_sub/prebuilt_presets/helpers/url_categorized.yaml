presets:
  # Preset for categorizing URls like so
  #
  # subscription_name:
  #   category_1:
  #     - https://...1
  #     - https://...2
  #   category_2:
  #     - url: https://...1
  #       metadata_field_1: 2011
  #       metadata_field_2: 'abc"
  #   ...
  #
  # Metadata field of `url` must exist, other ones can be anything.
  # Only supports a single level of nesting.
  _url_categorized:
    preset:
      - "_multi_url_bilateral"

    overrides:
      # Parameters:
      #   $0: url string or map containing url + metadata fields
      #   $1: category key
      #
      # Output:
      #  Map containing { url: ..., category: ..., metadata_field_1: ... }
      "%flat_array__url_to_map_format": >-
        {
          %elif(
            %is_map($0),
            %map_extend( $0, { "category": $1 } ),
            %is_string($0),
            { "url": $0, "category": $1 },
            %throw("If using album categories, each URL must be either a string or map with metadata fields")
          )
        }

      # Parameters:
      #  $0: category key
      #  $1: array of URLs in either string or map form
      #
      # Output:
      #   Array containing [{ url: ..., category: ... }, ... ]
      "%flat_array__category_to_map_format": >-
        { 
          %array_apply_fixed(
            %assert_then(
              %is_array( $1 ),
              $1,
              "If using album categories, each category must map to an array"
            ),
            $0,
            %flat_array__url_to_map_format 
          )
        }

      # Parameters:
      #  $0: map containing fields { url: <url_value>, category: ... }
      #
      # Output:
      #  Nested map containing { <url_value>: { url: <url_value>, category: ... } }
      "%flat_array__url_keyed_map_format": >-
        { { %map_get($0, "url"): $0 } }

      # Creates an array in the form of [ { url: ..., category: ..., metadata_field_1: ... }, ... ]
      category_url_array: >-
        { %array_flatten( %map_apply( subscription_map, %flat_array__category_to_map_format ) ) }

      # Creates a map in the form of { <url value>: { category: ..., metadata_field_1: ... }, ... }
      category_url_map: >-
        {
          %array_reduce(
            %array_apply( category_url_array, %flat_array__url_keyed_map_format ),
            %map_extend
          )
        }

      # Parameters:
      #   $0: metadata field to fetch for the current url
      #   $1: default value
      #
      # Output:
      #   Metadata field value if it exists. Otherwise, return default value
      "%get_url_field": >-
        { %map_get( %map( %map_get( category_url_map, ytdl_sub_input_url, {} ) ), $0, $1 ) }

      # Parameters:
      #   $0: metadata field to fetch for the current url
      #
      # Output:
      #   True if field is specified. False otherwise.
      "%contains_url_field": >-
        { %not( %is_null( %get_url_field( $0, null ) ) ) }
        

      # Parameters:
      #  $0: integer to fetch the i'th url using 1-based indexing
      #
      # Output:
      #   i'th url in the category map
      "%get_url_i": >-
        { 
          %map_get(
            %map( %array_at( category_url_array, %int( %sub($0, 1) ), {} ) ),
            "url",
            %array_at(subscription_array, %int( %sub($0, 1) ), null)
          )
        }

      subscription_map: "{ {} }"
      urls: "{ %array_apply(%range(100, 1), %get_url_i) }"